<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>python杂记</title>
      <link href="/2019/12/19/python%E6%9D%82%E8%AE%B0/"/>
      <url>/2019/12/19/python%E6%9D%82%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<hr><h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><h4 id="四个内置数据结构：列表、元组、字典、集合（80-）"><a href="#四个内置数据结构：列表、元组、字典、集合（80-）" class="headerlink" title="四个内置数据结构：列表、元组、字典、集合（80%）"></a>四个内置数据结构：列表、元组、字典、集合（80%）</h4><h4 id="1、列表-list-：有序的可变的对象集合"><a href="#1、列表-list-：有序的可变的对象集合" class="headerlink" title="1、列表(list)：有序的可变的对象集合"></a>1、列表(list)：有序的可变的对象集合</h4><p>列表是可变的，可以把列表类似于数组的概念，不同的是，python中的列表是动态的，会根据你的需要来动态的收缩和扩展。</p><p>另外，列表是异构的，即不需要声明储存对象的类型，甚至可以在一个列表中混合不同类型的对象。</p><table><thead><tr><th>对象</th><th align="center">索引值</th></tr></thead><tbody><tr><td>对象2</td><td align="center">2</td></tr><tr><td>对象1</td><td align="center">1</td></tr><tr><td>对象0</td><td align="center">0</td></tr></tbody></table><p>操作应用：</p><table><thead><tr><th>表达式</th><th align="center">结果说明</th></tr></thead><tbody><tr><td>lst * n</td><td align="center">把lst列表重复n次</td></tr><tr><td>lst[n1:n2]</td><td align="center">将索引值n1，n2对应的内容取出，组成另一个列表</td></tr><tr><td>del lst[n1:n2]</td><td align="center">删除索引值n1到n2之间的内容</td></tr><tr><td>lst[n1:n2] = n</td><td align="center">把n1到n2之间的元素设置为n</td></tr><tr><td>lst.append(x)</td><td align="center">将 x 视为一个元素，附加到列表末尾</td></tr><tr><td>lst.extend(x)</td><td align="center">将 x 中的所有元素附加到列表后面</td></tr><tr><td>lst.sort()</td><td align="center">将列表加以排序</td></tr><tr><td>lst.remove(x)</td><td align="center">删除列表中第一个出现的x</td></tr></tbody></table><p>下面展示的是 append 和 extend 的区别：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;lst = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;ext = [<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;lst.append(ext)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;lst</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,[<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;lst = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;lst.extend(ext)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;lst</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>]</span></pre></td></tr></table></figure><h4 id="2、元组-tuple-：有序的不可变的对象集合"><a href="#2、元组-tuple-：有序的不可变的对象集合" class="headerlink" title="2、元组(tuple)：有序的不可变的对象集合"></a>2、元组(tuple)：有序的不可变的对象集合</h4><p>因为元组的不可变特性，通常把元组想象成一个常量列表。</p><p>元组和列表很类似，不同的是元组不可变，这意味着，一旦元组被创建就不能被修改，不然会出现久违的 error</p><h4 id="3、字典-dict-：无序的键-值对集合"><a href="#3、字典-dict-：无序的键-值对集合" class="headerlink" title="3、字典(dict)：无序的键/值对集合"></a>3、字典(dict)：无序的键/值对集合</h4><p>字典是无序且可变的，可以把字典想象成一个两列多行的数据结构。</p><p>注意：因为字典是无序的，所以你不要指望编译器会按照你输入的顺序来依次输出它们</p><p>同样的，字典也是可以根据你的需求来动态的收缩或扩展。</p><table><thead><tr><th>键</th><th align="center">对象</th></tr></thead><tbody><tr><td>键#2</td><td align="center">对象2</td></tr><tr><td>键#1</td><td align="center">对象1</td></tr><tr><td>键#3</td><td align="center">对象3</td></tr></tbody></table><h4 id="4、集合-set-：无序的唯一对象的集合"><a href="#4、集合-set-：无序的唯一对象的集合" class="headerlink" title="4、集合(set)：无序的唯一对象的集合"></a>4、集合(set)：无序的唯一对象的集合</h4><p>集合像字典一样没有顺序，它的亮点在于它内部的对象都是唯一的，不允许存在重复的情况。</p><p>如果单纯用一对 {} 来给变量赋值，变量的类型会被认定为 dict，如果{}里面只有值，而没有键会被认为set</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>C语言小程序</title>
      <link href="/2019/12/12/C%E8%AF%AD%E8%A8%80%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
      <url>/2019/12/12/C%E8%AF%AD%E8%A8%80%E5%B0%8F%E7%A8%8B%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<p><a href="#jump1">汉诺塔</a></p><p><a href="#jump2">lihao</a></p><hr><p><span id="jump1">汉诺塔</span> </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="comment">将 n 个盘子从 A 移到 C 可以分解为三个步骤：</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="comment">（1）将 A 上的 n-1 个盘子借助C移动到 B 上；</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="comment">（2）把 A 上的剩下的一个盘子移动到 C 上；</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="comment">（3）把 n-1 个盘子从 B 借助 A 移动到 C 上。</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"><span class="comment">*/</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line"><span class="function"></span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">hanoi</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">char</span> one, <span class="keyword">char</span> two, <span class="keyword">char</span> three)</span></span>;      <span class="comment">//声明 hanoi 函数</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">int</span> m;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">    <span class="built_in">printf</span>(<span class="string">"input the number of diskes:"</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;m);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">    <span class="built_in">printf</span>(<span class="string">"The step to move %d diskes:\n"</span>, m);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">    hanoi(m, <span class="string">'A'</span> , <span class="string">'B'</span>, <span class="string">'C'</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hanoi</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">char</span> one, <span class="keyword">char</span> two, <span class="keyword">char</span> three)</span>         <span class="comment">//定义 hanoi 函数，其作用是将 n 个盘子从 one 借助 two 移动到 three 的过程</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line"><span class="function"></span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">move</span><span class="params">(<span class="keyword">char</span> x, <span class="keyword">char</span> y)</span></span>;                      <span class="comment">//声明 move 函数</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span>(n == <span class="number">1</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">      <span class="built_in">move</span>(one, three);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">else</span> </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line">       &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line">           hanoi(n<span class="number">-1</span>, one, three, two);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line">           <span class="built_in">move</span>(one, three);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">26</span></pre></td><td class="code"><pre><span class="line">           hanoi(n<span class="number">-1</span>, two, one, three);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">27</span></pre></td><td class="code"><pre><span class="line">       &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">28</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">29</span></pre></td><td class="code"><pre><span class="line">void move(char x, char y)  定义 move 函数，其作用是表示 x 到 y 的过程</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">30</span></pre></td><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">31</span></pre></td><td class="code"><pre><span class="line">    <span class="built_in">printf</span>(<span class="string">"%c --&gt; %c\n"</span>,x, y);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">32</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><p><span id="jump2">lihao</span> </p>]]></content>
      
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言笔记</title>
      <link href="/2019/12/05/C/"/>
      <url>/2019/12/05/C/</url>
      
        <content type="html"><![CDATA[<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h4 id="为什么要使用函数"><a href="#为什么要使用函数" class="headerlink" title="为什么要使用函数"></a>为什么要使用函数</h4><p>函数是什么呢？除了编译软件自带的函数外，用户是否可以自己定义一个函数并调用它呢？如果可以的话，这样将会使代码更加简洁明朗。</p><h4 id="一、声明"><a href="#一、声明" class="headerlink" title="一、声明"></a>一、声明</h4><p>在定义一个函数之前我们要赋予它一个函数名，而所谓函数名其实就是给一个某种功能起一个名字。</p><p>用户要定义的函数类型有 void(无类型，即没有返回值)、int（返回整数值）、float、double、char（返回字符）……</p><h4 id="二、定义"><a href="#二、定义" class="headerlink" title="二、定义"></a>二、定义</h4><p>1、定义无参函数</p><pre><code>类型名   函数名(){    函数体}</code></pre><p>2、定义有参函数</p><pre><code>类型名   函数名(类型+变量){    函数体}</code></pre><p>3、定义空函数</p><pre><code>类型名   函数名() { }   </code></pre><h4 id="三、调用函数"><a href="#三、调用函数" class="headerlink" title="三、调用函数"></a>三、调用函数</h4><p>1、调用函数之前需要在主函数的第一个语句中声明一下函数，因为编译是从main函数开始编译，当编译到用户定义的函数，如果之前没有对函数进行声明，就会出错。</p><p>2、<font color="#FF0000">函数的声明语句是一个语句，需要用 <strong>;</strong> 结尾</font></p><p>3、在调用过程中，系统会把实参的值传递给形参，而函数的返回值是由 return 语句获得的。<font color="red">函数的类型决定返回值的类型</font> 在未出现函数调用的时候，形参并不占用内存单元，发生调用的时候才会临时分配内存单元。<font color="red">调用结束后，形参单元被释放，实参单元仍保留原值。</font></p><p>4、例：</p><pre><code>//先定义函数还是先编写主函数没有什么差别，但本人倾向于先编写主函数#include&lt;stdio.h&gt;int main(){    int max(int x,int y);                      //对max函数声明 “;”不要忘    int a, b, c;    printf(&quot;please input two numbers:&quot;);    sacnf(&quot;%d %d&quot;,&amp;a,&amp;b);    c = max(a,b);                        //调用max函数    printf(&quot;max is %d&quot;,c);    return 0;}int max(int x,int y)         //定义max函数，其功能是求两个数中的最大值{    int z;    z = x &gt; y ? x : y;    return z;}</code></pre><h4 id="四、函数的嵌套"><a href="#四、函数的嵌套" class="headerlink" title="四、函数的嵌套"></a>四、函数的嵌套</h4><p>1、定义：直接或间接的调用函数本身，称为函数的递归调用。</p><p>2、规则：程序中不允许无终止的递归调用，必须加条件限制（if、 while、 for…… ）</p><p>3、特点：从一个已知的事实出发，按照一定规律推出下一个事实，再从这个新的已知事实出发，再向下一个新的事实。</p><p>3、例:用递归法求 n!</p><pre><code>/*   n 的阶乘就是从一，一直乘到 n; 当 n = 1, n! = 1;当 n &gt; 1, n! = n * (n - 1)!下面开始设计程序：*/#include&lt;stdio.h&gt;int main(){    int fac(int n);                //对fac函数声明    int n, y;    printf(&quot;input one number:&quot;);    scanf(&quot;%d&quot;,&amp;n);    y = fac(n);                          //调用fac函数，其作用是求一个数的阶乘    printf(&quot;%d! = %d\n&quot;,n, y);    return 0;}int fac(int n)                   //定义fac函数{    int f;    if(n &lt; 0)       printf(&quot;n &lt; 0, error&quot;);    else if(n == 0 || n == 1)       f = 1;    else f = fac(n - 1) * n;    return f;}</code></pre><h2 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h2><h4 id="一、数组和指针"><a href="#一、数组和指针" class="headerlink" title="一、数组和指针"></a>一、数组和指针</h4><p>*：取值操作符；</p><p>&amp;：取地址操作符；</p><p>操作符* 和操作符 &amp; 的优先级一样, 但是当* 和&amp;同时存在时, 原则是自右向左:<em>&amp;a = a; 首先运算 &amp;a 得到 a 的地址，然后进行</em>a 运算，得到变量a；&amp;<em>a = a的地址;</em>a 得到 a 的值,&amp;a 得到 a 的地址值。</p><p><code>a[i] = *(a + i);</code></p><p>数组和指针不一样，但是有相似的地方。<br>数组里面的每一个元素都有相应的地址；指针可以指向变量，也可以指向数组元素（类型要一致）。（数组元素的指针其实就是数组元素的地址）</p><p><font color="red">注意：</font>数组名a（一维数组和多维数组都是如此），在编译的时候会编译成第一个元素的地址。<br>初值：p = a  相当于 p = &amp;a[0]</p><p>p++ 中不是p的地址加一，而是p加一个单元。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Wonderful moment</title>
      <link href="/2019/11/30/filename/"/>
      <url>/2019/11/30/filename/</url>
      
        <content type="html"><![CDATA[<p>2019年11月25日中午，刚考完线代，下着小雨，我踏上了开往淮北的列车。</p><p>这是我们冷战结束的第一天，心里总觉得有些愧疚。就这样，我秘密的买好了票，想要给她一个惊喜。我事先骗她到操场走走，然后我们在操场“偶遇”。果然，这傻不啦叽的女孩，第一反应居然是发型凌乱。我们抱了许久，仔细想想好像很久都没有这样了，仿佛能听到她简单纯粹的激动和开心，那一刻，失望和不满荡然无存。这是异地恋的无奈……我们一起度过了美好的两天，等她下课，一起吃食堂，陪她打卡。我想尽量在属于她的世界里尽量留下我来过的痕迹，就当是我走后的温存吧。</p><p>亲爱的，下次见。</p><p><img src="https://i.loli.net/2019/12/08/2Q1zaJYvNUf4iK9.jpg" alt="11.26日晚于天桥下"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>我的第一篇博客</title>
      <link href="/2019/11/29/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/"/>
      <url>/2019/11/29/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/</url>
      
        <content type="html"><![CDATA[<p>历时两天，我的博客网站终于搭建完成，对于一个小白来说，这的确有些不容易，不过好在成功了。其实之前是没有这个想法的，但是最近有些朋友弄了，我当然也要玩玩。虽然现在我才19岁，但是十九年里发生的事我很多都不记得，我有时想，如果那些痕迹、那些有价值的事物都被忘记的话，那不仅仅是一个人，而是和他关联的一部分就自然而然地消失了啊。希望我能坚持写下去，记录生活的沙子、拾取成长的贝壳。</p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
