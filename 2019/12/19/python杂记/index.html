<!DOCTYPE html>
<html lang="">
  <head>
    
<meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width,user-scalable=no,initial-scale=1,minimum-scale=1,maximum-scale=1">


<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />



  <meta name="description" content="python杂记"/>








    <link rel="alternate" href="/default" title="Lihao">




    <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=1.1"/>



<link rel="canonical" href="https://MineWelt.github.io/2019/12/19/python杂记/"/>


<meta name="description" content="基础知识四个内置数据结构：列表、元组、字典、集合（80%）1、列表(list)：有序的可变的对象集合列表是可变的，可以把列表类似于数组的概念，不同的是，python中的列表是动态的，会根据你的需要来动态的收缩和扩展。 另外，列表是异构的，即不需要声明储存对象的类型，甚至可以在一个列表中混合不同类型的对象。    对象 索引值    对象2 2   对象1 1   对象0 0   操作应用：">
<meta property="og:type" content="article">
<meta property="og:title" content="python杂记">
<meta property="og:url" content="https:&#x2F;&#x2F;minewelt.github.io&#x2F;2019&#x2F;12&#x2F;19&#x2F;python%E6%9D%82%E8%AE%B0&#x2F;index.html">
<meta property="og:site_name" content="Lihao">
<meta property="og:description" content="基础知识四个内置数据结构：列表、元组、字典、集合（80%）1、列表(list)：有序的可变的对象集合列表是可变的，可以把列表类似于数组的概念，不同的是，python中的列表是动态的，会根据你的需要来动态的收缩和扩展。 另外，列表是异构的，即不需要声明储存对象的类型，甚至可以在一个列表中混合不同类型的对象。    对象 索引值    对象2 2   对象1 1   对象0 0   操作应用：">
<meta property="og:locale" content="zh-CN">
<meta property="og:updated_time" content="2019-12-27T14:37:18.098Z">
<meta name="twitter:card" content="summary">


<link rel="stylesheet" type="text/css" href="/css/style.css?v=1.1"/>
<link href='https://fonts.googleapis.com/css?family=Open+Sans' rel='stylesheet'>





<script type="text/javascript">
  var themeConfig = {
    fancybox: {
      enable: false
    },
  };
</script>




    





    





    <title> python杂记 - Lihao </title>
  </head>

  <body>
    <div id="page">
      <header id="masthead"><div class="site-header-inner">
    <h1 class="site-title">
        <a href="/." class="logo">Lihao</a>
    </h1>

    <nav id="nav-top">
        
            <ul id="menu-top" class="nav-top-items">
                
                    <li class="menu-item">
                        <a href="https://user.qzone.qq.com/1069460308/infocenter" target="_blank" rel="noopener">
                            
                            
                                Unsplash
                            
                        </a>
                    </li>
                
                    <li class="menu-item">
                        <a href="/about">
                            
                            
                                About
                            
                        </a>
                    </li>
                
                
            </ul>
        
    </nav>

</div>

      </header>
      <div id="content">
        
    <div id="primary">
        
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          python杂记
        
      </h1>

      <time class="post-time">
          12月 19 2019
      </time>
    </header>



    
            <div class="post-content">
            <hr>
<h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><h4 id="四个内置数据结构：列表、元组、字典、集合（80-）"><a href="#四个内置数据结构：列表、元组、字典、集合（80-）" class="headerlink" title="四个内置数据结构：列表、元组、字典、集合（80%）"></a>四个内置数据结构：列表、元组、字典、集合（80%）</h4><h4 id="1、列表-list-：有序的可变的对象集合"><a href="#1、列表-list-：有序的可变的对象集合" class="headerlink" title="1、列表(list)：有序的可变的对象集合"></a>1、列表(list)：有序的可变的对象集合</h4><p>列表是可变的，可以把列表类似于数组的概念，不同的是，python中的列表是动态的，会根据你的需要来动态的收缩和扩展。</p>
<p>另外，列表是异构的，即不需要声明储存对象的类型，甚至可以在一个列表中混合不同类型的对象。</p>
<table>
<thead>
<tr>
<th>对象</th>
<th align="center">索引值</th>
</tr>
</thead>
<tbody><tr>
<td>对象2</td>
<td align="center">2</td>
</tr>
<tr>
<td>对象1</td>
<td align="center">1</td>
</tr>
<tr>
<td>对象0</td>
<td align="center">0</td>
</tr>
</tbody></table>
<p>操作应用：</p>
<table>
<thead>
<tr>
<th>表达式</th>
<th align="center">结果说明</th>
</tr>
</thead>
<tbody><tr>
<td>lst * n</td>
<td align="center">把lst列表重复n次</td>
</tr>
<tr>
<td>lst[n1:n2]</td>
<td align="center">将索引值n1，n2对应的内容取出，组成另一个列表</td>
</tr>
<tr>
<td>del lst[n1:n2]</td>
<td align="center">删除索引值n1到n2之间的内容</td>
</tr>
<tr>
<td>lst[n1:n2] = n</td>
<td align="center">把n1到n2之间的元素设置为n</td>
</tr>
<tr>
<td>lst.append(x)</td>
<td align="center">将 x 视为一个元素，附加到列表末尾</td>
</tr>
<tr>
<td>lst.extend(x)</td>
<td align="center">将 x 中的所有元素附加到列表后面</td>
</tr>
<tr>
<td>lst.sort()</td>
<td align="center">将列表加以排序</td>
</tr>
<tr>
<td>lst.remove(x)</td>
<td align="center">删除列表中第一个出现的x</td>
</tr>
</tbody></table>
<p>下面展示的是 append 和 extend 的区别：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">0</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;lst = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;ext = [<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;lst.append(ext)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;lst</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,[<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;lst = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;lst.extend(ext)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;lst</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>]</span></pre></td></tr></table></figure>

<h4 id="2、元组-tuple-：有序的不可变的对象集合"><a href="#2、元组-tuple-：有序的不可变的对象集合" class="headerlink" title="2、元组(tuple)：有序的不可变的对象集合"></a>2、元组(tuple)：有序的不可变的对象集合</h4><p>因为元组的不可变特性，通常把元组想象成一个常量列表。</p>
<p>元组和列表很类似，不同的是元组不可变，这意味着，一旦元组被创建就不能被修改，不然会出现久违的 error</p>
<h4 id="3、字典-dict-：无序的键-值对集合"><a href="#3、字典-dict-：无序的键-值对集合" class="headerlink" title="3、字典(dict)：无序的键/值对集合"></a>3、字典(dict)：无序的键/值对集合</h4><p>字典是无序且可变的，可以把字典想象成一个两列多行的数据结构。</p>
<p>注意：因为字典是无序的，所以你不要指望编译器会按照你输入的顺序来依次输出它们</p>
<p>同样的，字典也是可以根据你的需求来动态的收缩或扩展。</p>
<table>
<thead>
<tr>
<th>键</th>
<th align="center">对象</th>
</tr>
</thead>
<tbody><tr>
<td>键#2</td>
<td align="center">对象2</td>
</tr>
<tr>
<td>键#1</td>
<td align="center">对象1</td>
</tr>
<tr>
<td>键#3</td>
<td align="center">对象3</td>
</tr>
</tbody></table>
<h4 id="4、集合-set-：无序的唯一对象的集合"><a href="#4、集合-set-：无序的唯一对象的集合" class="headerlink" title="4、集合(set)：无序的唯一对象的集合"></a>4、集合(set)：无序的唯一对象的集合</h4><p>集合像字典一样没有顺序，它的亮点在于它内部的对象都是唯一的，不允许存在重复的情况。</p>
<p>如果单纯用一对 {} 来给变量赋值，变量的类型会被认定为 dict，如果{}里面只有值，而没有键会被认为set</p>
<h4 id="判断语句"><a href="#判断语句" class="headerlink" title="判断语句"></a>判断语句</h4><h4 id="1-、if-elif-else"><a href="#1-、if-elif-else" class="headerlink" title="1 、if \ elif \ else"></a>1 、if \ elif \ else</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">0</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>  x == A:                     <span class="comment">#条件一</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    do something <span class="keyword">for</span> A</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">elif</span> x == B:                    <span class="comment">#条件二</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    do something <span class="keyword">for</span> B</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span>:                           <span class="comment">#条件三</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    do something <span class="keyword">for</span> C</span></pre></td></tr></table></figure>

<p>注意：if、elif、else 的后面一定要加  :</p>
<h4 id="循环语句"><a href="#循环语句" class="headerlink" title="循环语句"></a>循环语句</h4><p>在python中，对于已经知道循环次数的循环体或者至少知道预期对象，用 for ，而对于不知道循环次数的循环适合用while.</p>
<h5 id="1、for循环"><a href="#1、for循环" class="headerlink" title="1、for循环"></a>1、for循环</h5><p>形式:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">0</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> <span class="string">"变量"</span> <span class="keyword">in</span>  <span class="string">"遍历（循环）对象"</span>:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    表达式</span></pre></td></tr></table></figure>

<p>比如：依次打印一个列表的内容:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">0</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">list1 = [<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">9</span>]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> list1:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">   print(x)</span></pre></td></tr></table></figure>
<h5 id="2、while循环"><a href="#2、while循环" class="headerlink" title="2、while循环"></a>2、while循环</h5><p>形式：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">0</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> <span class="string">"条件"</span>:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">     <span class="string">"循环体"</span></span></pre></td></tr></table></figure>

<p>比如，模仿掷色子。因为在掷色子之前我们并不知道要循环几次才能得到我们想要的数字，所以要用while循环.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">0</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="comment">#导入random模板</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">x = random.randint(<span class="number">1</span>, <span class="number">6</span>)  <span class="comment">#先产生一个1—6的随机数，如果不是 5，就执行下面的循环</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">print(x)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="comment">#打印产生的随机数</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> x != <span class="number">5</span>:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">      x = random.randint(<span class="number">1</span>,<span class="number">6</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">      print(x)</span></pre></td></tr></table></figure>

<h4 id="break和continue"><a href="#break和continue" class="headerlink" title="break和continue"></a>break和continue</h4><p>break : 用于提前结束循环体</p>
<p>利用break，可以改写上面的掷色子小程序</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">0</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="comment">#导入random模板：调用randint函数产生随机数</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">     x = random.randint(<span class="number">1</span>,<span class="number">6</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">     print(x)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">     <span class="keyword">if</span> x == <span class="number">5</span>: <span class="keyword">break</span></span></pre></td></tr></table></figure>

<p>continue : 用于跳过本次循环，再从下一次循环开始。即只要遇到continue，立即放弃本次循环，回到 for/while .</p>
<h4 id="enmuerate"><a href="#enmuerate" class="headerlink" title="enmuerate()"></a>enmuerate()</h4><p>在for循环中，如果需要在循环中获取当前的索引值，可以使用enmuerate()函数：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">0</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">names = [<span class="string">'梦泪'</span>,<span class="string">'奥特曼'</span>,<span class="string">'孙悟空'</span>]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i, name <span class="keyword">in</span> enmuerate(names):</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    print(<span class="string">"No.&#123;&#125;:&#123;&#125;"</span>.format(i, name))</span></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">0</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">No<span class="number">.0</span>:梦泪</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">No<span class="number">.1</span>:奥特曼</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">No<span class="number">.2</span>:孙悟空</span></pre></td></tr></table></figure>

<h4 id="format"><a href="#format" class="headerlink" title="format"></a>format</h4><p>py2.6之后新增的函数 : str.format(). 通过 {} 代替 %</p>
<p>str.format()函数理论上可以接收无限个参数，而且位置也可以不按顺序.</p>
<p>比如 :</p>
<p>（1）不为参数设置指定位置</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">0</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;<span class="string">"&#123;&#125; &#123;&#125;"</span>.format(<span class="string">"hello"</span>, <span class="string">"lihao"</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="string">'hello lihao'</span></span></pre></td></tr></table></figure>

<p>（2）为参数设置指定位置</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">0</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;<span class="string">"&#123;1&#125; &#123;0&#125;"</span>.format(<span class="string">"hello"</span>. <span class="string">"lihao"</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="string">'lihao hello'</span></span></pre></td></tr></table></figure>

<h4 id="try-except-例外处理"><a href="#try-except-例外处理" class="headerlink" title="try/except 例外处理"></a>try/except 例外处理</h4><p>顾名思义,先 try（尝试） 一下，再用 except 捕捉出现例外的情况.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">0</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">try</span>:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">        int(input(<span class="string">"what's your age?"</span>))</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">break</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">except</span>:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">        print(<span class="string">"please enter a number!"</span>)</span></pre></td></tr></table></figure>

<p>为什么要多花几行代码呢？ 目的就是防止用户输入非数字的情况.</p>
<h4 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h4><p>python有一种针对处理有序数据的运算器，即迭代器.</p>
<p>1、 map 函数的用法:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">0</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">map(执行的函数, 容器变量)</span></pre></td></tr></table></figure>
<p>下面通过一个例子介绍用法:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">0</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pick</span><span class="params">(x)</span>:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    fruits = [<span class="string">'apple'</span>, <span class="string">'banana'</span>, <span class="string">'orange'</span>]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">return</span> fruits[x]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">#定义一个函数,通过索引值返回相应的水果</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">choices = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">1</span>]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">result = map(pick, choices)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> choice <span class="keyword">in</span> result:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    print(choice)</span></pre></td></tr></table></figure>
<p>程序的运行结果如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">0</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">banana</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">orange</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">apple</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">apple</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">orange</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">banana</span></pre></td></tr></table></figure>

<h4 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h4><h5 id="文件的读取与写入"><a href="#文件的读取与写入" class="headerlink" title="文件的读取与写入"></a>文件的读取与写入</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">0</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">f = open(<span class="string">"文件名"</span>, <span class="string">"文件处理方式"</span>)</span></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>操作</th>
<th align="center">功能</th>
</tr>
</thead>
<tbody><tr>
<td>r</td>
<td align="center">以只读方式打开文件。文件的指针将会放在文件的开头。这是默认模式。</td>
</tr>
<tr>
<td>w</td>
<td align="center">打开一个文件只用于写入。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件</td>
</tr>
<tr>
<td>a</td>
<td align="center">打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。也就是说，新的内容将会被写入到已有内容之后。如果该文件不存在，创建新文件进行写入</td>
</tr>
</tbody></table>
<p>一般情况下，读取文件的方法有三种 : read(), readline(), readlines().  </p>
<p>从字面意思上来看，read()是一口气读完, readline()像是一下读一行</p>
<h5 id="文件与目录的操作"><a href="#文件与目录的操作" class="headerlink" title="文件与目录的操作"></a>文件与目录的操作</h5>
            </div>
          

    
  </article>

    </div>

      </div>

      <footer id="colophon"><span class="copyright-year">
    
        &copy;
    
        2012 -
    
    2019
    <span class="footer-author">Lihao.</span>
    <span class="power-by">
        Powered by <a class="hexo-link" href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> and <a class="theme-link" href="https://github.com/henryhuang/hexo-theme-polarbearsimple" target="_blank" rel="noopener">Polar Bear Simple</a>
    </span>
</span>

      </footer>

      <div class="back-to-top" id="back-to-top">
        <i class="iconfont icon-up"></i>
      </div>
    </div>
    


    


    




  
    <script type="text/javascript" src="/lib/jquery/jquery-3.1.1.min.js"></script>
  

  

    <script type="text/javascript" src="/js/src/theme.js?v=1.1"></script>
<script type="text/javascript" src="/js/src/bootstrap.js?v=1.1"></script>

    

  
  <script type="application/ld+json">
  {
  "@context": "http://www.schema.org",
  "@type": "Person",
  "@id": "https://huangyijie.com/about/",
  "name": "黄奕杰",
  "alternateName": "Henry Huang",
  "nationality": "中国",
  "birthPlace" : {
    "@type": "Place",
      "address": {
        "@type": "PostalAddress",
      "addressLocality": "汕头市",
      "addressRegion": "广东省",
          "addressCountry": "中国"
    }
  },
  "gender": "Male",
  "Description": "Software Engineer",
  "disambiguatingDescription": "Full stack software engineer, focus on Java and JavaScript.",
  "jobTitle": "Software Engineer",
  "url": "https://huangyijie.com",
  "image": "https://s.gravatar.com/avatar/4e0e61fdf1b2bcfb4ee31da27601fe6b?s=512&r=g",
  "address": {
    "@type": "PostalAddress",
    "addressLocality": "深圳市",
    "addressRegion": "广东省",
    "addressCountry": "中国"
  },
  "sameAs": [
    "http://weibo.com/626242034",
    "https://github.com/henryhuang",
    "https://unsplash.com/@henryhh"
    ]
  }
  </script>
  </body>
</html>
