{"meta":{"title":"Lihao","subtitle":"","description":"","author":"Lihao","url":"https://MineWelt.github.io","root":"/"},"pages":[{"title":"","date":"2019-11-30T12:44:36.208Z","updated":"2019-11-30T12:44:36.208Z","comments":true,"path":"photos/README.html","permalink":"https://minewelt.github.io/photos/README.html","excerpt":"","text":"photos"}],"posts":[{"title":"self到底是什么","slug":"self到底是什么","date":"2019-12-28T08:05:04.000Z","updated":"2019-12-29T03:27:53.763Z","comments":true,"path":"2019/12/28/self到底是什么/","link":"","permalink":"https://minewelt.github.io/2019/12/28/self%E5%88%B0%E5%BA%95%E6%98%AF%E4%BB%80%E4%B9%88/","excerpt":"","text":"最近在学习类和对象的时候，类中定义的一个函数总是有一个参数是self,它并没有被赋值,它到底是干啥的？？？ 在我们尝试搞清楚self之前, 我们应该搞清楚类与对象的概念 对象对象=属性+方法 对象不一定非要在类中,将对象放在类中只是为了实现批量的 “生产”. 这样，我们就定义了一个类对象. 因此, 对象无处不在, 类就是类对象, 函数也是对象… 类正所谓, 物以类聚，人以群分. 类就是一些具有共同特征的一个组合,是有一定的特有属性（静态的、动态的）. 举个简单的例子： 01class People: #python中的类名约定以大写字母开头，以示与函数名的区分2 #属性（其实就是一些变量）3 legs = 24 arms = 25 mouth = 16 appearance = [\"ugly\", \"beautiful\"]7 color = [\"white\", \"black\", \"yellow\"]8 #方法（其实就是一个个的函数）9 def eat(self):10 print(\"人是铁饭是钢,一顿不吃饿得慌!\")11 def drink(self):12 print(\"据说人一直不喝水只能坚持3天...\")13 def sleep(self):14 print(\"睡觉喽o(*￣▽￣*)ブ\") 这样，我们就定义了一个名为People的类，这个类有自己特有的的属性和方法： 有两条腿、两个胳膊、一个嘴… 它也具有一些动态的特性: 睡觉、吃饭、喝水… 实例对象01&gt;&gt;&gt; p = People() 见证伟大的时刻到了: 我们就创建了一个名为 p 的实例对象 !!! 当然, 我们也可以不给它命名, 直接用下面的方法也同样创建了一个实例对象， 只不过…我们还没有给它上户口. 01&gt;&gt;&gt; People() 实例对象被创建之后, 我们就可以尽情的享用它内部的方法 （函数） 了. 好了, 有了这些概念, 我们就可以放心大胆的回答 self 的用法了. self 是什么？经过例子我们大概可以知道 : 类中的方法与普通函数只有一个区别——即它们除了用户所给他设定的函数之外, 还有一个额外的第一个参数, 但是你不需要为这个参数赋值, python 会自动帮其赋值. self 是固定的吗？虽然这个参数的名字不一定非要是 self , 但是这已经成为了 python 中约定俗成的标准. 对, 就是这样, 不要你觉得, 我只要我觉得. 我可以不加 self 吗?一般情况下, 当然可以了, 前提是如果你不想看到 TypeError: a() takes 0 positional arguments but 1 was given 的话. 即使一个方法中没有任何参数, 仍需有 self. 其实非要说的话, 如果定义和调用的时候不传递类实例就可以… 01&gt;&gt;&gt;class Test:2&gt;&gt;&gt; def p():3&gt;&gt;&gt; print(__class__)4&gt;&gt;&gt;5&gt;&gt;&gt;Test.p()6&gt;&gt;&gt;&lt;class '__main__.Test'&gt;","categories":[],"tags":[]},{"title":"Web spider","slug":"Web-spider","date":"2019-12-26T03:00:05.000Z","updated":"2019-12-27T12:32:33.122Z","comments":true,"path":"2019/12/26/Web-spider/","link":"","permalink":"https://minewelt.github.io/2019/12/26/Web-spider/","excerpt":"","text":"框架1.发起请求： 通过HTTP库向目标站点发起请求，即发送一个Request，请求可以包含额外的headers、data等信息，然后等待服务器响应。这个请求的过程就像我们打开浏览器，在浏览器地址栏输入网址：www.baidu.com，然后点击回车。这个过程其实就相当于浏览器作为一个浏览的客户端，向服务器端发送了一次请求。 2.获取响应内容： 如果服务器能正常响应，我们会得到一个Response，Response的内容便是所要获取的内容，类型可能有HTML、Json字符串，二进制数据(图片，视频等）等类型。这个过程就是服务器接收客户端的请求，进过解析发送给浏览器的网页HTML文件。 3.解析内容： 得到的内容可能是HTML，可以使用正则表达式，网页解析库进行解析。也可能是Json，可以直接转为Json对象解析。可能是二进制数据，可以做保存或者进一步处理。这一步相当于浏览器把服务器端的文件获取到本地，再进行解释并且展现出来。 4.保存数据： 保存的方式可以是把数据存为文本，也可以把数据保存到数据库，或者保存为特定的jpg，mp4 等格式的文件。这就相当于我们在浏览网页时，下载了网页上的图片或者视频。 互联网就是一个蜘蛛网，每一个结点都是一个域名，编写一个蜘蛛，爬来爬去，爬取有用的内容. python3访问网页的方法并解析1、发起请求 : 首先调用urllib包里面的request模块. 01import urllib.request 2、获取响应内容 : 然后我们要用urlopen打开网页. 01response = urllib.request.urlopen(url, data=None, [timeout,]*, cafile=None, capath=None, cadefault=False, context=None) data = None :urlopen () 的data参数默认为None，当data参数不为空的时候，urlopen () 提交方式为Post ( Post的数据必须是bytes或者iterable of bytes，不能是str，如果是str需要进行encode（）编码 ) 3.解析内容 : 不同的对象用不同的解析方式(HTML、Json、二进制数据) 解析所用的方法因对象的不同而有所改变，但是大同小异，不同的对象有不同的解析方式. 01html = response.read() 例一 : 下载一张图片01import urllib.request2#导入urllib包里面的request模板3response = urllib.request.urlopen('图片地址')4image = response.read()5with open('图片名字.jpg','wb') as f:6 f.write(image) 运行之后就会在该程序的根目录下生成一张 .jpg 格式的图片 例二 ： 实现有道翻译的翻译功能01import urllib.request2import urllib.parse3import json4#json,parse后续...5while True:6 words = input(\"请输入带翻译的内容(输入///退出程序)：\")7 if words == '///':8 break9#输入‘///’退出10 url = 'http://fanyi.youdao.com/translate?smartresult=dict&amp;smartresult=rule' 11##其实原地址是：http://fanyi.youdao.com/translate_o?smartresult=dict&amp;smartresult=rule但是不知道为什么会出错，百度之后说要把地址中的“ _o ” 去掉即可. 玄学...12 data = &#123;&#125;13 data['i'] = words14 data['from'] = 'AUTO'15 data['to'] = 'AUTO'16 data['smartresult'] = 'dict'17 data['client'] = 'fanyideskweb'18 data['salt'] = '15773261561679'19 data['sign'] = '45006f026f56b799575021abb8b24433'20 data['ts'] = '1577326156167'21 data['bv'] = '42160534cfa82a6884077598362bbc9d'22 data['doctype'] = 'json'23 data['version'] = '2.1'24 data['keyfrom'] = 'fanyi.web'25 data = urllib.parse.urlencode(data).encode('utf-8')26 response = urllib.request.urlopen(url, data)27 html = response.read().decode('utf-8')28 target = json.loads(html)29 result = target['translateResult'][0][0]['tgt']30 print(result)","categories":[],"tags":[]},{"title":"python杂记","slug":"python杂记","date":"2019-12-19T15:25:40.000Z","updated":"2019-12-27T14:37:18.098Z","comments":true,"path":"2019/12/19/python杂记/","link":"","permalink":"https://minewelt.github.io/2019/12/19/python%E6%9D%82%E8%AE%B0/","excerpt":"","text":"基础知识四个内置数据结构：列表、元组、字典、集合（80%）1、列表(list)：有序的可变的对象集合列表是可变的，可以把列表类似于数组的概念，不同的是，python中的列表是动态的，会根据你的需要来动态的收缩和扩展。 另外，列表是异构的，即不需要声明储存对象的类型，甚至可以在一个列表中混合不同类型的对象。 对象 索引值 对象2 2 对象1 1 对象0 0 操作应用： 表达式 结果说明 lst * n 把lst列表重复n次 lst[n1:n2] 将索引值n1，n2对应的内容取出，组成另一个列表 del lst[n1:n2] 删除索引值n1到n2之间的内容 lst[n1:n2] = n 把n1到n2之间的元素设置为n lst.append(x) 将 x 视为一个元素，附加到列表末尾 lst.extend(x) 将 x 中的所有元素附加到列表后面 lst.sort() 将列表加以排序 lst.remove(x) 删除列表中第一个出现的x 下面展示的是 append 和 extend 的区别： 01&gt;&gt;&gt;lst = [1,2,3]2&gt;&gt;&gt;ext = [5,5,5]3&gt;&gt;&gt;lst.append(ext)4&gt;&gt;&gt;lst5[1,2,3,[5,5,5]6&gt;&gt;&gt;lst = [1,2,3]7&gt;&gt;&gt;lst.extend(ext)8&gt;&gt;&gt;lst9[1,2,3,5,5,5] 2、元组(tuple)：有序的不可变的对象集合因为元组的不可变特性，通常把元组想象成一个常量列表。 元组和列表很类似，不同的是元组不可变，这意味着，一旦元组被创建就不能被修改，不然会出现久违的 error 3、字典(dict)：无序的键/值对集合字典是无序且可变的，可以把字典想象成一个两列多行的数据结构。 注意：因为字典是无序的，所以你不要指望编译器会按照你输入的顺序来依次输出它们 同样的，字典也是可以根据你的需求来动态的收缩或扩展。 键 对象 键#2 对象2 键#1 对象1 键#3 对象3 4、集合(set)：无序的唯一对象的集合集合像字典一样没有顺序，它的亮点在于它内部的对象都是唯一的，不允许存在重复的情况。 如果单纯用一对 {} 来给变量赋值，变量的类型会被认定为 dict，如果{}里面只有值，而没有键会被认为set 判断语句1 、if \\ elif \\ else01if x == A: #条件一2 do something for A3elif x == B: #条件二4 do something for B5else: #条件三6 do something for C 注意：if、elif、else 的后面一定要加 : 循环语句在python中，对于已经知道循环次数的循环体或者至少知道预期对象，用 for ，而对于不知道循环次数的循环适合用while. 1、for循环形式: 01for \"变量\" in \"遍历（循环）对象\":2 表达式 比如：依次打印一个列表的内容: 01list1 = [1,3,5,7,9]2for x in list1:3 print(x) 2、while循环形式： 01while \"条件\":2 \"循环体\" 比如，模仿掷色子。因为在掷色子之前我们并不知道要循环几次才能得到我们想要的数字，所以要用while循环. 01import random2#导入random模板3x = random.randint(1, 6) #先产生一个1—6的随机数，如果不是 5，就执行下面的循环4print(x)5#打印产生的随机数6while x != 5:7 x = random.randint(1,6)8 print(x) break和continuebreak : 用于提前结束循环体 利用break，可以改写上面的掷色子小程序 01import random2#导入random模板：调用randint函数产生随机数3while True:4 x = random.randint(1,6)5 print(x)6 if x == 5: break continue : 用于跳过本次循环，再从下一次循环开始。即只要遇到continue，立即放弃本次循环，回到 for/while . enmuerate()在for循环中，如果需要在循环中获取当前的索引值，可以使用enmuerate()函数： 01names = ['梦泪','奥特曼','孙悟空']2for i, name in enmuerate(names):3 print(\"No.&#123;&#125;:&#123;&#125;\".format(i, name)) 01No.0:梦泪2No.1:奥特曼3No.2:孙悟空 formatpy2.6之后新增的函数 : str.format(). 通过 {} 代替 % str.format()函数理论上可以接收无限个参数，而且位置也可以不按顺序. 比如 : （1）不为参数设置指定位置 01&gt;&gt;&gt;\"&#123;&#125; &#123;&#125;\".format(\"hello\", \"lihao\")2'hello lihao' （2）为参数设置指定位置 01&gt;&gt;&gt;\"&#123;1&#125; &#123;0&#125;\".format(\"hello\". \"lihao\")2'lihao hello' try/except 例外处理顾名思义,先 try（尝试） 一下，再用 except 捕捉出现例外的情况. 01while True:2 try:3 int(input(\"what's your age?\"))4 break5 except:6 print(\"please enter a number!\") 为什么要多花几行代码呢？ 目的就是防止用户输入非数字的情况. 迭代器python有一种针对处理有序数据的运算器，即迭代器. 1、 map 函数的用法: 01map(执行的函数, 容器变量) 下面通过一个例子介绍用法: 01def pick(x):2 fruits = ['apple', 'banana', 'orange']3 return fruits[x]4 #定义一个函数,通过索引值返回相应的水果5choices = [1, 2, 0, 0, 2, 1]6result = map(pick, choices)7for choice in result:8 print(choice) 程序的运行结果如下: 01banana2orange3apple4apple5orange6banana 文件文件的读取与写入01f = open(\"文件名\", \"文件处理方式\") 操作 功能 r 以只读方式打开文件。文件的指针将会放在文件的开头。这是默认模式。 w 打开一个文件只用于写入。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件 a 打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。也就是说，新的内容将会被写入到已有内容之后。如果该文件不存在，创建新文件进行写入 一般情况下，读取文件的方法有三种 : read(), readline(), readlines(). 从字面意思上来看，read()是一口气读完, readline()像是一下读一行 文件与目录的操作","categories":[],"tags":[]},{"title":"C语言小程序","slug":"C语言小程序","date":"2019-12-12T05:16:12.000Z","updated":"2019-12-27T06:57:23.589Z","comments":true,"path":"2019/12/12/C语言小程序/","link":"","permalink":"https://minewelt.github.io/2019/12/12/C%E8%AF%AD%E8%A8%80%E5%B0%8F%E7%A8%8B%E5%BA%8F/","excerpt":"","text":"汉诺塔 lihao 汉诺塔 01/*2将 n 个盘子从 A 移到 C 可以分解为三个步骤：3（1）将 A 上的 n-1 个盘子借助C移动到 B 上；4（2）把 A 上的剩下的一个盘子移动到 C 上；5（3）把 n-1 个盘子从 B 借助 A 移动到 C 上。6*/7#include&lt;stdio.h&gt;8int main()9&#123;10 void hanoi(int n, char one, char two, char three); //声明 hanoi 函数11 int m;12 printf(\"input the number of diskes:\");13 scanf(\"%d\", &amp;m);14 printf(\"The step to move %d diskes:\\n\", m);15 hanoi(m, 'A' , 'B', 'C');16&#125;17void hanoi(int n, char one, char two, char three) //定义 hanoi 函数，其作用是将 n 个盘子从 one 借助 two 移动到 three 的过程18&#123;19 void move(char x, char y); //声明 move 函数20 if(n == 1)21 move(one, three);22 else 23 &#123;24 hanoi(n-1, one, three, two);25 move(one, three);26 hanoi(n-1, two, one, three);27 &#125;28&#125;29void move(char x, char y) 定义 move 函数，其作用是表示 x 到 y 的过程30&#123;31 printf(\"%c --&gt; %c\\n\",x, y);32&#125; lihao","categories":[],"tags":[{"name":"C","slug":"C","permalink":"https://minewelt.github.io/tags/C/"}]},{"title":"C语言笔记","slug":"C","date":"2019-12-05T14:51:31.000Z","updated":"2019-12-14T13:36:49.513Z","comments":true,"path":"2019/12/05/C/","link":"","permalink":"https://minewelt.github.io/2019/12/05/C/","excerpt":"","text":"函数为什么要使用函数函数是什么呢？除了编译软件自带的函数外，用户是否可以自己定义一个函数并调用它呢？如果可以的话，这样将会使代码更加简洁明朗。 一、声明在定义一个函数之前我们要赋予它一个函数名，而所谓函数名其实就是给一个某种功能起一个名字。 用户要定义的函数类型有 void(无类型，即没有返回值)、int（返回整数值）、float、double、char（返回字符）…… 二、定义1、定义无参函数 类型名 函数名() { 函数体 }2、定义有参函数 类型名 函数名(类型+变量) { 函数体 }3、定义空函数 类型名 函数名() { } 三、调用函数1、调用函数之前需要在主函数的第一个语句中声明一下函数，因为编译是从main函数开始编译，当编译到用户定义的函数，如果之前没有对函数进行声明，就会出错。 2、函数的声明语句是一个语句，需要用 ; 结尾 3、在调用过程中，系统会把实参的值传递给形参，而函数的返回值是由 return 语句获得的。函数的类型决定返回值的类型 在未出现函数调用的时候，形参并不占用内存单元，发生调用的时候才会临时分配内存单元。调用结束后，形参单元被释放，实参单元仍保留原值。 4、例： //先定义函数还是先编写主函数没有什么差别，但本人倾向于先编写 主函数 #include&lt;stdio.h&gt; int main() { int max(int x,int y); //对max函数声明 “;”不要忘 int a, b, c; printf(&quot;please input two numbers:&quot;); sacnf(&quot;%d %d&quot;,&amp;a,&amp;b); c = max(a,b); //调用max函数 printf(&quot;max is %d&quot;,c); return 0; } int max(int x,int y) //定义max函数，其功能是求两个数中的最大值 { int z; z = x &gt; y ? x : y; return z; }四、函数的嵌套1、定义：直接或间接的调用函数本身，称为函数的递归调用。 2、规则：程序中不允许无终止的递归调用，必须加条件限制（if、 while、 for…… ） 3、特点：从一个已知的事实出发，按照一定规律推出下一个事实，再从这个新的已知事实出发，再向下一个新的事实。 3、例:用递归法求 n! /* n 的阶乘就是从一，一直乘到 n; 当 n = 1, n! = 1; 当 n &gt; 1, n! = n * (n - 1)! 下面开始设计程序： */ #include&lt;stdio.h&gt; int main() { int fac(int n); //对fac函数声明 int n, y; printf(&quot;input one number:&quot;); scanf(&quot;%d&quot;,&amp;n); y = fac(n); //调用fac函数，其作用是求一个数的阶乘 printf(&quot;%d! = %d\\n&quot;,n, y); return 0; } int fac(int n) //定义fac函数 { int f; if(n &lt; 0) printf(&quot;n &lt; 0, error&quot;); else if(n == 0 || n == 1) f = 1; else f = fac(n - 1) * n; return f; }指针一、数组和指针*：取值操作符； &amp;：取地址操作符； 操作符* 和操作符 &amp; 的优先级一样, 但是当* 和&amp;同时存在时, 原则是自右向左:&amp;a = a; 首先运算 &amp;a 得到 a 的地址，然后进行a 运算，得到变量a；&amp;a = a的地址;a 得到 a 的值,&amp;a 得到 a 的地址值。 a[i] = *(a + i); 数组和指针不一样，但是有相似的地方。数组里面的每一个元素都有相应的地址；指针可以指向变量，也可以指向数组元素（类型要一致）。（数组元素的指针其实就是数组元素的地址） 注意：数组名a（一维数组和多维数组都是如此），在编译的时候会编译成第一个元素的地址。初值：p = a 相当于 p = &amp;a[0] p++ 中不是p的地址加一，而是p加一个单元。","categories":[],"tags":[]},{"title":"Wonderful moment","slug":"filename","date":"2019-11-30T07:07:23.000Z","updated":"2019-12-12T04:18:15.475Z","comments":true,"path":"2019/11/30/filename/","link":"","permalink":"https://minewelt.github.io/2019/11/30/filename/","excerpt":"","text":"2019年11月25日中午，刚考完线代，下着小雨，我踏上了开往淮北的列车。 这是我们冷战结束的第一天，心里总觉得有些愧疚。就这样，我秘密的买好了票，想要给她一个惊喜。我事先骗她到操场走走，然后我们在操场“偶遇”。果然，这傻不啦叽的女孩，第一反应居然是发型凌乱。我们抱了许久，仔细想想好像很久都没有这样了，仿佛能听到她简单纯粹的激动和开心，那一刻，失望和不满荡然无存。这是异地恋的无奈……我们一起度过了美好的两天，等她下课，一起吃食堂，陪她打卡。我想尽量在属于她的世界里尽量留下我来过的痕迹，就当是我走后的温存吧。 亲爱的，下次见。","categories":[],"tags":[]},{"title":"我的第一篇博客","slug":"我的第一篇博客","date":"2019-11-29T02:45:04.000Z","updated":"2019-12-19T15:24:04.534Z","comments":true,"path":"2019/11/29/我的第一篇博客/","link":"","permalink":"https://minewelt.github.io/2019/11/29/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/","excerpt":"","text":"历时两天，我的博客网站终于搭建完成，对于一个小白来说，这的确有些不容易，不过好在成功了。其实之前是没有这个想法的，但是最近有些朋友弄了，我当然也要玩玩。虽然现在我才19岁，但是十九年里发生的事我很多都不记得，我有时想，如果那些痕迹、那些有价值的事物都被忘记的话，那不仅仅是一个人，而是和他关联的一部分就自然而然地消失了啊。希望我能坚持写下去，记录生活的沙子、拾取成长的贝壳。","categories":[],"tags":[]}]}