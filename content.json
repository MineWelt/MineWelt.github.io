{"meta":{"title":"Lihao","subtitle":"","description":"","author":"Lihao","url":"https://MineWelt.github.io","root":"/"},"pages":[{"title":"","date":"2019-11-30T12:44:36.208Z","updated":"2019-11-30T12:44:36.208Z","comments":true,"path":"photos/README.html","permalink":"https://minewelt.github.io/photos/README.html","excerpt":"","text":"photos"}],"posts":[{"title":"python杂记","slug":"python杂记","date":"2019-12-19T15:25:40.000Z","updated":"2019-12-25T05:43:39.660Z","comments":true,"path":"2019/12/19/python杂记/","link":"","permalink":"https://minewelt.github.io/2019/12/19/python%E6%9D%82%E8%AE%B0/","excerpt":"","text":"基础知识四个内置数据结构：列表、元组、字典、集合（80%）1、列表(list)：有序的可变的对象集合列表是可变的，可以把列表类似于数组的概念，不同的是，python中的列表是动态的，会根据你的需要来动态的收缩和扩展。 另外，列表是异构的，即不需要声明储存对象的类型，甚至可以在一个列表中混合不同类型的对象。 对象 索引值 对象2 2 对象1 1 对象0 0 操作应用： 表达式 结果说明 lst * n 把lst列表重复n次 lst[n1:n2] 将索引值n1，n2对应的内容取出，组成另一个列表 del lst[n1:n2] 删除索引值n1到n2之间的内容 lst[n1:n2] = n 把n1到n2之间的元素设置为n lst.append(x) 将 x 视为一个元素，附加到列表末尾 lst.extend(x) 将 x 中的所有元素附加到列表后面 lst.sort() 将列表加以排序 lst.remove(x) 删除列表中第一个出现的x 下面展示的是 append 和 extend 的区别： 1&gt;&gt;&gt;lst = [1,2,3]2&gt;&gt;&gt;ext = [5,5,5]3&gt;&gt;&gt;lst.append(ext)4&gt;&gt;&gt;lst5[1,2,3,[5,5,5]6&gt;&gt;&gt;lst = [1,2,3]7&gt;&gt;&gt;lst.extend(ext)8&gt;&gt;&gt;lst9[1,2,3,5,5,5] 2、元组(tuple)：有序的不可变的对象集合因为元组的不可变特性，通常把元组想象成一个常量列表。 元组和列表很类似，不同的是元组不可变，这意味着，一旦元组被创建就不能被修改，不然会出现久违的 error 3、字典(dict)：无序的键/值对集合字典是无序且可变的，可以把字典想象成一个两列多行的数据结构。 注意：因为字典是无序的，所以你不要指望编译器会按照你输入的顺序来依次输出它们 同样的，字典也是可以根据你的需求来动态的收缩或扩展。 键 对象 键#2 对象2 键#1 对象1 键#3 对象3 4、集合(set)：无序的唯一对象的集合集合像字典一样没有顺序，它的亮点在于它内部的对象都是唯一的，不允许存在重复的情况。 如果单纯用一对 {} 来给变量赋值，变量的类型会被认定为 dict，如果{}里面只有值，而没有键会被认为set 判断语句1 、if \\ elif \\ else1if x == A: #条件一2 do something for A3elif x == B: #条件二4 do something for B5else: #条件三6 do something for C 注意：if、elif、else 的后面一定要加 : 循环语句在python中，对于已经知道循环次数的循环体或者至少知道预期对象，用 for ，而对于不知道循环次数的循环适合用while. 1、for循环形式: 1for \"变量\" in \"遍历（循环）对象\":2 表达式 比如：依次打印一个列表的内容: 1list1 = [1,3,5,7,9]2for x in list1:3 print(x) 2、while循环形式： 1while \"条件\":2 \"循环体\" 比如，模仿掷色子。因为在掷色子之前我们并不知道要循环几次才能得到我们想要的数字，所以要用while循环. 1import random23x = random.randint(1, 6) #先产生一个1—6的随机数，如果不是 5，就执行下面的循环4print(x)56while x != 5:7 x = random.randint(1,6)8 print(x) break和continuebreak : 用于提前结束循环体 利用break，可以改写上面的掷色子小程序 1import random23while True:4 x = random.randint(1,6)5 print(x)6 if x == 5: break continue : 用于跳过本次循环，再从下一次循环开始。即只要遇到continue，立即放弃本次循环，回到 for/while . enmuerate()在for循环中，如果需要在循环中获取当前的索引值，可以使用enmuerate()函数： 1names = ['梦泪','奥特曼','孙悟空']2for i, name in enmuerate(names):3 print(\"No.&#123;&#125;:&#123;&#125;\".format(i, name)) 1No.0:梦泪2No.1:奥特曼3No.2:孙悟空","categories":[],"tags":[]},{"title":"C语言小程序","slug":"C语言小程序","date":"2019-12-12T05:16:12.000Z","updated":"2019-12-23T03:08:55.982Z","comments":true,"path":"2019/12/12/C语言小程序/","link":"","permalink":"https://minewelt.github.io/2019/12/12/C%E8%AF%AD%E8%A8%80%E5%B0%8F%E7%A8%8B%E5%BA%8F/","excerpt":"","text":"汉诺塔 lihao 汉诺塔 1/*2将 n 个盘子从 A 移到 C 可以分解为三个步骤：3（1）将 A 上的 n-1 个盘子借助C移动到 B 上；4（2）把 A 上的剩下的一个盘子移动到 C 上；5（3）把 n-1 个盘子从 B 借助 A 移动到 C 上。6*/7#include&lt;stdio.h&gt;8int main()9&#123;10 void hanoi(int n, char one, char two, char three); //声明 hanoi 函数11 int m;12 printf(\"input the number of diskes:\");13 scanf(\"%d\", &amp;m);14 printf(\"The step to move %d diskes:\\n\", m);15 hanoi(m, 'A' , 'B', 'C');16&#125;17void hanoi(int n, char one, char two, char three) //定义 hanoi 函数，其作用是将 n 个盘子从 one 借助 two 移动到 three 的过程18&#123;19 void move(char x, char y); //声明 move 函数20 if(n == 1)21 move(one, three);22 else 23 &#123;24 hanoi(n-1, one, three, two);25 move(one, three);26 hanoi(n-1, two, one, three);27 &#125;28&#125;29void move(char x, char y) 定义 move 函数，其作用是表示 x 到 y 的过程30&#123;31 printf(\"%c --&gt; %c\\n\",x, y);32&#125; lihao","categories":[],"tags":[{"name":"C","slug":"C","permalink":"https://minewelt.github.io/tags/C/"}]},{"title":"C语言笔记","slug":"C","date":"2019-12-05T14:51:31.000Z","updated":"2019-12-14T13:36:49.513Z","comments":true,"path":"2019/12/05/C/","link":"","permalink":"https://minewelt.github.io/2019/12/05/C/","excerpt":"","text":"函数为什么要使用函数函数是什么呢？除了编译软件自带的函数外，用户是否可以自己定义一个函数并调用它呢？如果可以的话，这样将会使代码更加简洁明朗。 一、声明在定义一个函数之前我们要赋予它一个函数名，而所谓函数名其实就是给一个某种功能起一个名字。 用户要定义的函数类型有 void(无类型，即没有返回值)、int（返回整数值）、float、double、char（返回字符）…… 二、定义1、定义无参函数 类型名 函数名() { 函数体 }2、定义有参函数 类型名 函数名(类型+变量) { 函数体 }3、定义空函数 类型名 函数名() { } 三、调用函数1、调用函数之前需要在主函数的第一个语句中声明一下函数，因为编译是从main函数开始编译，当编译到用户定义的函数，如果之前没有对函数进行声明，就会出错。 2、函数的声明语句是一个语句，需要用 ; 结尾 3、在调用过程中，系统会把实参的值传递给形参，而函数的返回值是由 return 语句获得的。函数的类型决定返回值的类型 在未出现函数调用的时候，形参并不占用内存单元，发生调用的时候才会临时分配内存单元。调用结束后，形参单元被释放，实参单元仍保留原值。 4、例： //先定义函数还是先编写主函数没有什么差别，但本人倾向于先编写 主函数 #include&lt;stdio.h&gt; int main() { int max(int x,int y); //对max函数声明 “;”不要忘 int a, b, c; printf(&quot;please input two numbers:&quot;); sacnf(&quot;%d %d&quot;,&amp;a,&amp;b); c = max(a,b); //调用max函数 printf(&quot;max is %d&quot;,c); return 0; } int max(int x,int y) //定义max函数，其功能是求两个数中的最大值 { int z; z = x &gt; y ? x : y; return z; }四、函数的嵌套1、定义：直接或间接的调用函数本身，称为函数的递归调用。 2、规则：程序中不允许无终止的递归调用，必须加条件限制（if、 while、 for…… ） 3、特点：从一个已知的事实出发，按照一定规律推出下一个事实，再从这个新的已知事实出发，再向下一个新的事实。 3、例:用递归法求 n! /* n 的阶乘就是从一，一直乘到 n; 当 n = 1, n! = 1; 当 n &gt; 1, n! = n * (n - 1)! 下面开始设计程序： */ #include&lt;stdio.h&gt; int main() { int fac(int n); //对fac函数声明 int n, y; printf(&quot;input one number:&quot;); scanf(&quot;%d&quot;,&amp;n); y = fac(n); //调用fac函数，其作用是求一个数的阶乘 printf(&quot;%d! = %d\\n&quot;,n, y); return 0; } int fac(int n) //定义fac函数 { int f; if(n &lt; 0) printf(&quot;n &lt; 0, error&quot;); else if(n == 0 || n == 1) f = 1; else f = fac(n - 1) * n; return f; }指针一、数组和指针*：取值操作符； &amp;：取地址操作符； 操作符* 和操作符 &amp; 的优先级一样, 但是当* 和&amp;同时存在时, 原则是自右向左:&amp;a = a; 首先运算 &amp;a 得到 a 的地址，然后进行a 运算，得到变量a；&amp;a = a的地址;a 得到 a 的值,&amp;a 得到 a 的地址值。 a[i] = *(a + i); 数组和指针不一样，但是有相似的地方。数组里面的每一个元素都有相应的地址；指针可以指向变量，也可以指向数组元素（类型要一致）。（数组元素的指针其实就是数组元素的地址） 注意：数组名a（一维数组和多维数组都是如此），在编译的时候会编译成第一个元素的地址。初值：p = a 相当于 p = &amp;a[0] p++ 中不是p的地址加一，而是p加一个单元。","categories":[],"tags":[]},{"title":"Wonderful moment","slug":"filename","date":"2019-11-30T07:07:23.000Z","updated":"2019-12-12T04:18:15.475Z","comments":true,"path":"2019/11/30/filename/","link":"","permalink":"https://minewelt.github.io/2019/11/30/filename/","excerpt":"","text":"2019年11月25日中午，刚考完线代，下着小雨，我踏上了开往淮北的列车。 这是我们冷战结束的第一天，心里总觉得有些愧疚。就这样，我秘密的买好了票，想要给她一个惊喜。我事先骗她到操场走走，然后我们在操场“偶遇”。果然，这傻不啦叽的女孩，第一反应居然是发型凌乱。我们抱了许久，仔细想想好像很久都没有这样了，仿佛能听到她简单纯粹的激动和开心，那一刻，失望和不满荡然无存。这是异地恋的无奈……我们一起度过了美好的两天，等她下课，一起吃食堂，陪她打卡。我想尽量在属于她的世界里尽量留下我来过的痕迹，就当是我走后的温存吧。 亲爱的，下次见。","categories":[],"tags":[]},{"title":"我的第一篇博客","slug":"我的第一篇博客","date":"2019-11-29T02:45:04.000Z","updated":"2019-12-19T15:24:04.534Z","comments":true,"path":"2019/11/29/我的第一篇博客/","link":"","permalink":"https://minewelt.github.io/2019/11/29/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/","excerpt":"","text":"历时两天，我的博客网站终于搭建完成，对于一个小白来说，这的确有些不容易，不过好在成功了。其实之前是没有这个想法的，但是最近有些朋友弄了，我当然也要玩玩。虽然现在我才19岁，但是十九年里发生的事我很多都不记得，我有时想，如果那些痕迹、那些有价值的事物都被忘记的话，那不仅仅是一个人，而是和他关联的一部分就自然而然地消失了啊。希望我能坚持写下去，记录生活的沙子、拾取成长的贝壳。","categories":[],"tags":[]}]}