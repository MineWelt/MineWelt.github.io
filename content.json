{"meta":{"title":"Lihao","subtitle":"","description":"","author":"Lihao","url":"https://MineWelt.github.io","root":"/"},"pages":[{"title":"","date":"2019-11-30T12:44:36.208Z","updated":"2019-11-30T12:44:36.208Z","comments":true,"path":"photos/README.html","permalink":"https://minewelt.github.io/photos/README.html","excerpt":"","text":"photos"}],"posts":[{"title":"C语言小程序","slug":"C语言小程序","date":"2019-12-12T05:16:12.000Z","updated":"2019-12-19T14:10:41.987Z","comments":true,"path":"2019/12/12/C语言小程序/","link":"","permalink":"https://minewelt.github.io/2019/12/12/C%E8%AF%AD%E8%A8%80%E5%B0%8F%E7%A8%8B%E5%BA%8F/","excerpt":"","text":"汉诺塔： /* 将 n 个盘子从 A 移到 C 可以分解为三个步骤： （1）将 A 上的 n-1 个盘子借助C移动到 B 上； （2）把 A 上的剩下的一个盘子移动到 C 上； （3）把 n-1 个盘子从 B 借助 A 移动到 C 上。 */ #include&lt;stdio.h&gt; int main() { void hanoi(int n, char one, char two, char three); //声明 hanoi 函数 int m; printf(&quot;input the number of diskes:&quot;); scanf(&quot;%d&quot;, &amp;m); printf(&quot;The step to move %d diskes:\\n&quot;, m); hanoi(m, &apos;A&apos; , &apos;B&apos;, &apos;C&apos;); } void hanoi(int n, char one, char two, char three) //定义 hanoi 函数，其作用是将 n 个盘子从 one 借助 two 移动到 three 的过程 { void move(char x, char y); //声明 move 函数 if(n == 1) move(one, three); else { hanoi(n-1, one, three, two); move(one, three); hanoi(n-1, two, one, three); } } void move(char x, char y) 定义 move 函数，其作用是表示 x 到 y 的过程 { printf(&quot;%c --&gt; %c\\n&quot;,x, y); }","categories":[],"tags":[]},{"title":"C语言笔记","slug":"C","date":"2019-12-05T14:51:31.000Z","updated":"2019-12-14T13:36:49.513Z","comments":true,"path":"2019/12/05/C/","link":"","permalink":"https://minewelt.github.io/2019/12/05/C/","excerpt":"","text":"函数为什么要使用函数函数是什么呢？除了编译软件自带的函数外，用户是否可以自己定义一个函数并调用它呢？如果可以的话，这样将会使代码更加简洁明朗。 一、声明在定义一个函数之前我们要赋予它一个函数名，而所谓函数名其实就是给一个某种功能起一个名字。 用户要定义的函数类型有 void(无类型，即没有返回值)、int（返回整数值）、float、double、char（返回字符）…… 二、定义1、定义无参函数 类型名 函数名() { 函数体 }2、定义有参函数 类型名 函数名(类型+变量) { 函数体 }3、定义空函数 类型名 函数名() { } 三、调用函数1、调用函数之前需要在主函数的第一个语句中声明一下函数，因为编译是从main函数开始编译，当编译到用户定义的函数，如果之前没有对函数进行声明，就会出错。 2、函数的声明语句是一个语句，需要用 ; 结尾 3、在调用过程中，系统会把实参的值传递给形参，而函数的返回值是由 return 语句获得的。函数的类型决定返回值的类型 在未出现函数调用的时候，形参并不占用内存单元，发生调用的时候才会临时分配内存单元。调用结束后，形参单元被释放，实参单元仍保留原值。 4、例： //先定义函数还是先编写主函数没有什么差别，但本人倾向于先编写 主函数 #include&lt;stdio.h&gt; int main() { int max(int x,int y); //对max函数声明 “;”不要忘 int a, b, c; printf(&quot;please input two numbers:&quot;); sacnf(&quot;%d %d&quot;,&amp;a,&amp;b); c = max(a,b); //调用max函数 printf(&quot;max is %d&quot;,c); return 0; } int max(int x,int y) //定义max函数，其功能是求两个数中的最大值 { int z; z = x &gt; y ? x : y; return z; }四、函数的嵌套1、定义：直接或间接的调用函数本身，称为函数的递归调用。 2、规则：程序中不允许无终止的递归调用，必须加条件限制（if、 while、 for…… ） 3、特点：从一个已知的事实出发，按照一定规律推出下一个事实，再从这个新的已知事实出发，再向下一个新的事实。 3、例:用递归法求 n! /* n 的阶乘就是从一，一直乘到 n; 当 n = 1, n! = 1; 当 n &gt; 1, n! = n * (n - 1)! 下面开始设计程序： */ #include&lt;stdio.h&gt; int main() { int fac(int n); //对fac函数声明 int n, y; printf(&quot;input one number:&quot;); scanf(&quot;%d&quot;,&amp;n); y = fac(n); //调用fac函数，其作用是求一个数的阶乘 printf(&quot;%d! = %d\\n&quot;,n, y); return 0; } int fac(int n) //定义fac函数 { int f; if(n &lt; 0) printf(&quot;n &lt; 0, error&quot;); else if(n == 0 || n == 1) f = 1; else f = fac(n - 1) * n; return f; }指针一、数组和指针*：取值操作符； &amp;：取地址操作符； 操作符* 和操作符 &amp; 的优先级一样, 但是当* 和&amp;同时存在时, 原则是自右向左:&amp;a = a; 首先运算 &amp;a 得到 a 的地址，然后进行a 运算，得到变量a；&amp;a = a的地址;a 得到 a 的值,&amp;a 得到 a 的地址值。 a[i] = *(a + i); 数组和指针不一样，但是有相似的地方。数组里面的每一个元素都有相应的地址；指针可以指向变量，也可以指向数组元素（类型要一致）。（数组元素的指针其实就是数组元素的地址） 注意：数组名a（一维数组和多维数组都是如此），在编译的时候会编译成第一个元素的地址。初值：p = a 相当于 p = &amp;a[0] p++ 中不是p的地址加一，而是p加一个单元。","categories":[],"tags":[]},{"title":"Wonderful moment","slug":"filename","date":"2019-11-30T07:07:23.000Z","updated":"2019-12-12T04:18:15.475Z","comments":true,"path":"2019/11/30/filename/","link":"","permalink":"https://minewelt.github.io/2019/11/30/filename/","excerpt":"","text":"2019年11月25日中午，刚考完线代，下着小雨，我踏上了开往淮北的列车。 这是我们冷战结束的第一天，心里总觉得有些愧疚。就这样，我秘密的买好了票，想要给她一个惊喜。我事先骗她到操场走走，然后我们在操场“偶遇”。果然，这傻不啦叽的女孩，第一反应居然是发型凌乱。我们抱了许久，仔细想想好像很久都没有这样了，仿佛能听到她简单纯粹的激动和开心，那一刻，失望和不满荡然无存。这是异地恋的无奈……我们一起度过了美好的两天，等她下课，一起吃食堂，陪她打卡。我想尽量在属于她的世界里尽量留下我来过的痕迹，就当是我走后的温存吧。 亲爱的，下次见。","categories":[],"tags":[]},{"title":"我的第一篇博客","slug":"我的第一篇博客","date":"2019-11-29T02:45:04.000Z","updated":"2019-12-07T14:14:34.797Z","comments":true,"path":"2019/11/29/我的第一篇博客/","link":"","permalink":"https://minewelt.github.io/2019/11/29/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/","excerpt":"","text":"历时两天，我的博客网站终于搭建完成，对于一个小白来说，这的确有些不容易，不过好在成功了。其实之前是没有这个想法的，但是最近有些朋友弄了，我当然也要玩玩。虽然现在我才19岁，但是十九年里发生的事我很多都不记得，我有时想，如果那些痕迹、那些有价值的事物都被忘记的话，那不仅仅是一个人，而是和他关联的一部分就自然而然地消失了啊。希望我能坚持写下去，记录生活的沙子、拾取成长的贝壳。","categories":[],"tags":[]}]}